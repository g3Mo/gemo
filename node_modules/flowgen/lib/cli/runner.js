"use strict";

exports.__esModule = true;
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _fs = _interopRequireDefault(require("fs"));

var _util = require("./util");

var _meta = _interopRequireDefault(require("./meta"));

var _beautifier = _interopRequireDefault(require("./beautifier"));

var _compiler = _interopRequireDefault(require("./compiler"));

var _defaultExporter = _interopRequireDefault(require("./default-exporter"));

var _flowTypedExporter = _interopRequireDefault(require("./flow-typed-exporter"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const readDir = (0, _util.promisify)(_fs.default.readdir);

async function outputFile(flowDefinitions, {
  intro,
  file,
  moduleName,
  outputFile
}, options, writeFile) {
  // Produce the flow library content
  try {
    const absoluteOutputFilePath = await writeFile(outputFile, (0, _beautifier.default)(intro + flowDefinitions)); // Check if we should compile tests as well

    if (options.compileTests) {
      // Assume tests file is in same dir, named <filename>-tests.ts
      // Based on DD conventions
      const testFileName = _path.default.dirname(file) + "/" + moduleName + "-tests.ts";
      const testFileOutput = _path.default.dirname(absoluteOutputFilePath) + "/test_" + moduleName + ".js"; // Try to compile the test file. Will fail silently if not present.

      _compiler.default.compileTest(testFileName, testFileOutput);
    }
  } catch (e) {
    console.error("Parsing", moduleName, "failed");
    console.error(e);
  }
}

function getFile(file, options, rawFile, isInDir) {
  // Get the module name from the file name
  const moduleName = getModuleNameFromFile(file); // The format of the output argument varies a bit based on which
  // exporting format we're using. For flow-typed, only the module name
  // is required, otherwise we use the cli arg.

  const outputFile = getOutputFile(options, file, rawFile, isInDir);
  const mode = getMode(options, file, isInDir); // Get the intro text

  let intro = (0, _meta.default)(moduleName, options.version, options.addFlowHeader || mode === "directory");
  return {
    file,
    outputFile,
    moduleName,
    intro,
    mode
  };
}

async function bfs(rootDir, options) {
  const queue = [];
  const files = [];
  queue.push(rootDir);
  let current;

  while (queue.length) {
    current = queue.shift();

    try {
      const dir = await readDir(current, {
        withFileTypes: true
      });

      for (const file of dir) {
        if (file.isDirectory()) {
          queue.push(_path.default.join(current, file.name));
        } else {
          if (!file.name.endsWith(".d.ts")) continue;
          files.push(getFile(_path.default.join(current, file.name), options, rootDir, true));
        }
      }
    } catch (_unused) {
      files.push(getFile(current, options, rootDir, false));
    }
  }

  return files;
}

var _default = options => {
  // No real reason to return an object here instead of combining
  // the compile function into the wrapper, but I like the API it produces.
  return {
    compile: async rawFiles => {
      let files = []; // Iterate all the files the user has passed in

      for (const rawFile of rawFiles) {
        files.push(...(await bfs(rawFile, options)));
      }

      if (files.length > 1) {
        const sources = _compiler.default.compileDefinitionFiles(files.map(v => v.file), {
          jsdoc: options.jsdoc,
          quiet: options.quiet,
          interfaceRecords: options.interfaceRecords,
          moduleExports: options.moduleExports
        });

        for (let index = 0; index < sources.length; index++) {
          const [, flowDefinitions] = sources[index];
          const file = files[index];
          let writeFile = _defaultExporter.default;
          if (file.mode === "flow-typed") writeFile = _flowTypedExporter.default; // Let the user know what's going on

          if (files.length >= 3) {
            // If we're compiling a lot of files, show more stats
            const progress = Math.round((index + 1) / files.length * 100);
            process.stdout.write("\r\x1b[K");
            process.stdout.write(progress + "% | " + file.moduleName);
          } else {
            console.log("Parsing", file.moduleName);
          }

          outputFile(flowDefinitions, file, options, writeFile);
        }
      } else {
        const file = files[0];

        const flowDefinitions = _compiler.default.compileDefinitionFile(file.file, {
          jsdoc: options.jsdoc,
          quiet: options.quiet,
          interfaceRecords: options.interfaceRecords,
          moduleExports: options.moduleExports
        });

        let writeFile = _defaultExporter.default;
        if (file.mode === "flow-typed") writeFile = _flowTypedExporter.default; // Let the user know what's going on

        console.log("Parsing", file.moduleName);
        outputFile(flowDefinitions, file, options, writeFile);
      }

      if (files.length >= 3) process.stdout.write("\n");
    }
  };
};

exports.default = _default;

function getModuleNameFromFile(fileName) {
  return _path.default.basename(fileName).replace(".d.ts", "");
}

function getMode(options, file, isDir) {
  if (isDir) return "directory";
  if (options.flowTypedFormat) return "flow-typed";
  return "file";
}

function getOutputFile(options, file, prefix, isDir) {
  if (isDir) {
    return _path.default.normalize(file.replace(prefix, `exports${_path.default.sep}`).replace(".d.ts", ".js.flow"));
  }

  if (options.flowTypedFormat) {
    return getModuleNameFromFile(file);
  } else {
    return options.out;
  }
}